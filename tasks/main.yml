---

- name: Disable port ldap 389
  ansible.posix.firewalld:
    zone: public
    service: ldap
    permanent: true
    immediate: true
    state: disabled
  tags: firewalld

- name: Open port ldaps 636
  ansible.posix.firewalld:
    zone: public
    service: "{{ item }}"
    permanent: true
    immediate: true
    state: enabled
  loop:
    - ldaps
    # - ssh
    # - dns
  tags: firewalld

- name: Block from external network
  ansible.posix.firewalld:
    rich_rule: rule family="ipv4" source NOT address="{{
      ansible_default_ipv4.network + '/' + ansible_default_ipv4.prefix | string }}" port port="636" protocol="tcp" reject
    zone: public
    permanent: true
    immediate: true
    state: enabled

- name: Set ldap internal IP in /etc/hosts
  ansible.builtin.lineinfile:
    path: /etc/hosts
    line: "{{ ldap_host_ip_internal | d('') + ' ' + ldap_host }}"
    regexp: ".* {{ ldap_host }}"
    state: "{{ (ldap_host_ip_internal | d('') is truthy) | ternary('present', 'absent') }}"

# the next task will return:
# - _container_storage_dir_base_local
# - _container_storage_dir_base
# - _group, _owner
# - _systemd_scope
# - _systemd_service_files_dir
# - _xdg_runtime_dir
- name: Include podman_init_vars.yml from sleif.podman
  ansible.builtin.include_tasks: "{{ lookup('first_found', params) }}"
  vars:
    params:
      files: sleif.podman/tasks/includes/podman_init_vars.yml
      paths: "{{ lookup('config', 'DEFAULT_ROLES_PATH') }}"
  tags: always

- name: Create certificate update script
  ansible.builtin.copy:
    dest: /usr/local/bin/ldap389ds_certificate_update.sh
    content: |
      #!/bin/bash
      podman unshare mkdir -p {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/data;
      podman unshare mkdir -p {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/ca;
      podman unshare diff -q {{ certificate_src }}/{{
      ldap_host }}/{{ ldap_host }}.crt {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/{{ ldap_host }}.crt || (
      podman unshare cp -aTLv --remove-destination {{ certificate_src }}/{{ ldap_host }} {{ _container_storage_dir_base }}/{{
      ldap389ds_container_name }}/tls;
      podman unshare csplit -z -f {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/ca/ca -b '%02d'.crt {{
      _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/{{ ldap_host }}.crt '/-----BEGIN CERTIFICATE-----/' '{*}' -q;
      podman unshare mv {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/ca/ca00.crt {{ _container_storage_dir_base }}/{{
      ldap389ds_container_name }}/tls/server.crt;
      podman unshare mv {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/{{ ldap_host }}.key {{ _container_storage_dir_base }}/{{
      ldap389ds_container_name }}/tls/server.key;
      podman unshare chown -Rh {{ ldap389ds_container_root_uid }}:{{ ldap389ds_container_root_uid }}  {{ _container_storage_dir_base }}/{{
      ldap389ds_container_name }}/tls {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/data
      )
    mode: '0755'
  tags: ldapcron

- name: Initial fill certificate directory
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.command: /usr/local/bin/ldap389ds_certificate_update.sh
  register: _result
  changed_when: _result.rc != 0
  until:
    - _result.rc == 0
  retries: 1
  delay: 10
  tags: ldapcron

# container initialization: /usr/libexec/dirsrv/dscontainer
- name: include_role sleif.podman podman_operation podman_create_container for ldap389ds
  when: false
  ansible.builtin.include_role:
    name: sleif.podman
    apply:
      tags:
        - podman_container_create
  vars:
    # podman_rootless: true
    # podman_network_name: "{{ podman_networks.podman_network_rootless.podman_network_name if podman_rootless | bool else
    #   podman_networks.podman_network_root.podman_network_name }}"
    podman_operation: podman_container_create
    container_name: '{{ ldap389ds_container_name }}'
    target: "{{ pod_name if pod_name | d('') is truthy else ldap389ds_container_name }}"
    _container:
      name: '{{ container_name }}'
      image:
        name: 'quay.io/389ds/dirsrv'
        tag: '{{ ldap389ds_container_version }}'
      pod: "{{ pod_name | default('') }}"
      # network: "{{ podman_network_name if pod_name | d('') is falsy else [] }}"
      # network: "slirp4netns:port_handler=slirp4netns"
      # security_opts: label:type:docker_t
      publish: "{{ ['3636:3636', '3389:3389'] if pod_name | d('') is falsy else [] }}"
      volumes:
        - {'host': '{{ _container_storage_dir_base_local }}/{{ ldap389ds_container_name }}/data', 'target': '/data:Z', 'mode': '0755'}
        - {'host': '{{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls', 'target': '/data/tls:Z', 'mode': '0700'}
      secrets:
        - {name: 'ldap_admin_password', data: '{{ ldap_auth_admin.bind_pw }}'}
        - {name: 'ldap_config_password', data: '{{ ldap_auth_config.bind_pw }}'}
      healthcheck: 'dsctl slapd-localhost healthcheck'
      env:
        # https://www.port389.org/docs/389ds/howto/howto-deploy-389ds-on-openshift.html
        # DS_DM_PASSWORD: secretpassword
        DS_SUFFIX_NAME: "{{ ldap_base_dn }}"
        DS_DM_PASSWORD: "{{ ldap_admin_password }}"
        # LDAP_ADMIN_PASSWORD_FILE: "/run/secrets/ldap_admin_password"
        # # LDAP_ADMIN_PASSWORD: "{{ ldap_admin_password }}"
        # LDAP_CONFIG_ADMIN_ENABLED: "yes"
        # LDAP_CONFIG_ADMIN_USER: "admin"
        # LDAP_CONFIG_ADMIN_PASSWORD_FILE: "/run/secrets/ldap_config_password"
        # # LDAP_CONFIG_ADMIN_PASSWORD: "{{ ldap_config_password }}"
        # LDAP_USER_DC: "{{ ldap_user_dc | d('users') }}"
        # # LDAP_USERS: "{{ ldap_readonly_user_username }}"
        # # LDAP_PASSWORDS: "{{ ldap_readonly_user_password }}"
        # LDAP_PASSWORDS: ""
        # LDAP_SKIP_DEFAULT_TREE: "yes"
        # LDAP_ENABLE_TLS: "yes"
        # # LDAP_REQUIRE_TLS: "yes"
        # LDAP_TLS_CERT_FILE: "/opt/bitnami/openldap/certs/{{ ldap_host }}.crt"
        # LDAP_TLS_KEY_FILE: "/opt/bitnami/openldap/certs/{{ ldap_host }}.key"
        # LDAP_TLS_CA_FILE: "/opt/bitnami/openldap/certs/{{ ldap_host }}.crt"
        # # LDAP_TLS_DH_PARAMS_FILE:
        # LDAP_TLS_VERIFY_CLIENTS: "never"
        # LDAP_ALLOW_ANON_BINDING: "no"
        # LDAP_CONFIGURE_PPOLICY: "yes"
        # LDAP_PPOLICY_HASH_CLEARTEXT: "yes"
        TZ: "Europe/Berlin"
      timezone: "Europe/Berlin"
  # no_log: true
  tags: podman_container_create

- name: Enable cronjob to provide letsencrypt certificates for ldap
  ansible.builtin.cron:
    name: "provide ldap certs"
    cron_file: ldap389ds_certificate_update
    user: "{{ podman_user }}"
    job: /usr/local/bin/ldap389ds_certificate_update.sh
  tags: ldapcron

- name: Ensure cron mail go to root
  ansible.builtin.cron:
    cron_file: ldap389ds_certificate_update
    user: "{{ podman_user }}"
    env: true
    name: "MAILTO"
    job: "root"
  tags: ldapcron

- name: Install openldap-clients
  ansible.builtin.package:
    name: openldap-clients
  tags: skipttag

- name: Add variable to ignore certificate chain
  ansible.builtin.lineinfile:
    dest: /etc/openldap/ldap.conf
    line: "TLS_REQCERT never"

- name: Install python-ldap
  ansible.builtin.package:
    name: python-ldap
  tags: skipttag

# TODO: more time for first initialization
- name: Wait for ldap service
  ansible.builtin.wait_for:
    port: 3636
    timeout: 60

- name: Check for suffix existence.
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.command: >
    podman exec {{ ldap389ds_container_name }} ldapsearch -x -H ldap://localhost:3389 -D "cn=Directory Manager" -y "/run/secrets/ldap_admin_password" -b "{{
      ldap_base_dn }}" -s base
  register: _ldapsearch_suffix
  changed_when: false
  failed_when:
    - _ldapsearch_suffix.rc not in [0, 32]

- name: Create the suffix
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.command: >
    podman exec {{ ldap389ds_container_name }} dsconf -D "cn=Directory Manager" -y "/run/secrets/ldap_admin_password" ldap://localhost:3389
    backend create --suffix "{{ ldap_base_dn }}"  --be-name "userRoot" --create-suffix
  register: _create_suffix
  when:
    - _ldapsearch_suffix.rc == 32
  changed_when: true

# depending on using a backuo you have to adapt dn: module{0} vs. module{1}
- name: Enable memberof module
  community.general.ldap_attrs:
    dn: cn=MemberOf Plugin,cn=plugins,cn=config
    attributes:
      memberofgroupattr:
        - "uniqueMember"
      nsslapd-pluginEnabled:
        - "on"
    state: exact
    server_uri: "ldaps://localhost:3636"
    bind_dn: "cn=Directory Manager"
    bind_pw: "{{ ldap_admin_password }}"
    # server_uri: "{{ ldap_auth_config.server_uri }}"
    # bind_dn: "{{ ldap_auth_config.bind_dn }}"
    # bind_pw: "{{ ldap_auth_config.bind_pw }}"
  register: _memberof_result
  # until:
  #   - not ( (_memberof_result.failed | bool ) and ('Type or value exists' not in _memberof_result.details) ) or not (_memberof_result.failed | bool )
  # retries: 100
  # delay: 10
  failed_when: >
    (_memberof_result.failed | bool ) and
    ("'desc': 'Type or value exists'" not in _memberof_result.details)
  tags:
    - ldap_config_memberof
  ignore_errors: true

# TODO fixup task required? dsconf -D "cn=Directory Manager" -y "/run/secrets/ldap_admin_password" ldap://localhost:3389 plugin memberof fixup-status

- name: Create LDAP content
  when: ldap_initial_local_data_file | d('') is falsy
  block:
    - name: Ldap create LDAP admin user
      community.general.ldap_entry:
        dn: "{{ ldap_auth_admin.bind_dn }}"
        objectClass:
          - simpleSecurityObject
          - organizationalRole
        attributes:
          description: "LDAP read only user"
          # cn: "{{ ldap_readonly_user_username }}"
          userPassword: "{{ ldap_auth_admin.bind_pw }}"
          # userPassword: "{{ '{SSHA}' + ldap_readonly_user_password }}"
        server_uri: "ldaps://localhost:3636"
        # server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "cn=Directory Manager"
        bind_pw: "{{ ldap_admin_password }}"
        # bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        # bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      tags:
        - ldap_ou

    - name: Ldap create LDAP read only user
      community.general.ldap_entry:
        dn: "{{ 'cn=' + ldap_readonly_user_username + ',' + ldap_base_dn }}"
        objectClass:
          - simpleSecurityObject
          - organizationalRole
        attributes:
          description: "LDAP read only user"
          # cn: "{{ ldap_readonly_user_username }}"
          userPassword: "{{ ldap_readonly_user_password }}"
          # userPassword: "{{ '{SSHA}' + ldap_readonly_user_password }}"
        server_uri: "ldaps://localhost:3636"
        # server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "cn=Directory Manager"
        bind_pw: "{{ ldap_admin_password }}"
        # bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        # bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      tags:
        - ldap_ou

- name: setup aci for admin and ldap_readonly
  community.general.ldap_attrs:
    dn: "{{ ldap_base_dn }}"
    attributes:
      aci:
        # default domain acl
        # - (targetattr="dc || description || objectClass")(targetfilter="(objectClass=domain)")(version 3.0; acl "Enable anyone domain read";
        #   allow (read, search, compare)(userdn="ldap:///anyone");)
        - (targetattr="userPassword || shadowLastChange")(version 3.0; acl "Password policy"; allow (write) userdn="ldap:///{{
          ldap_auth_admin.bind_dn }}"; allow (write) userdn="ldap:///self"; allow (compare,search,read) userdn="ldap:///anyone";)
        - (targetattr="*")(version 3.0; acl "General access"; allow (read,search,compare) userdn="ldap:///self"; allow (all) userdn="ldap:///{{
          ldap_auth_admin.bind_dn }}"; allow (read,search,compare) userdn="ldap:///{{ 'cn=' + ldap_readonly_user_username + ',' + ldap_base_dn }}";)
    # state: exact
    server_uri: "ldaps://localhost:3636"
    # server_uri: "{{ ldap_auth_config.server_uri }}"
    bind_dn: "cn=Directory Manager"
    bind_pw: "{{ ldap_admin_password }}"
  register: _aci_result
  failed_when: >
    (_aci_result.failed | bool ) and
    ("'desc': 'Type or value exists'" not in _aci_result.details)
  tags:
    - ldap_config_memberof
  ignore_errors: true

# ldap389ds config restore: slapadd -c -F /etc/ldap/slapd.d -n 0 ldap389ds.config
# ldap389ds data restore: slapadd -c -F /etc/ldap/slapd.d -n 2 ldap389ds.data
- name: Create backup directory for {{ ldap389ds_container_name }}
  ansible.builtin.file:
    path: "{{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}_backups"
    state: directory
    owner: "{{ _owner }}"
    group: "{{ _group }}"
    mode: '0700'
  register: _backup_dir_create
  tags:
    - ldap389ds_backup

- name: Ensure gzip is installed
  ansible.builtin.package:
    name: gzip
    state: present
  tags:
    - ldap389ds_backup

- name: Add cronjob for daily ldap389ds db dumps
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.cron:
    name: "Daily ldap389ds db dump"
    minute: "21"
    hour: "*/4"
    job: podman exec {{ ldap389ds_container_name }} sh -c 'dsctl slapd-localhost db2bak'
  tags:
    - ldap389ds_backup

- name: Find old backups
  ansible.builtin.find:
    paths: "{{ _container_storage_dir_base_local }}/{{ ldap389ds_container_name }}/data/bak"
    age: "14d"
    recurse: true
  register: _old_backups

- name: Delete old backups
  ansible.builtin.file:
    path: "{{ item.path }}"
    state: absent
  loop: "{{ _old_backups.files }}"
  when: _old_backups.matched > 0

- name: Add cronjob for daily ldap389ds data backup
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.cron:
    name: "Daily ldap389ds data backup"
    minute: "24"
    hour: "*/4"
    job: >
      podman exec "{{ ldap389ds_container_name }}" sh -c 'ldapsearch -x -D "cn=Directory Manager" -y  "/run/secrets/ldap_admin_password"
      -H ldap://localhost:3389 -b "{{ ldap_base_dn }}"
      "(objectClass=*)" > "/data/bak/{{ ldap_base_dn | replace('=', '_') | replace(',', '_') }}_$(date +\%Y\%m\%d).ldif"'
  tags:
    - ldap389ds_backup

- debug: var=_aci_result
- pause:

- name: Configure logrotate for the database dump
  ansible.builtin.template:
    src: logrotate.cfg.j2
    dest: "/etc/logrotate.d/{{ ldap389ds_container_name }}.cfg"
    mode: '0644'
  tags:
    - ldap389ds_backup

- name: Selinux enable logrotate on NFS
  ansible.posix.seboolean:
    name: logrotate_use_nfs
    state: true
    persistent: true
  when:
    - ansible_selinux and ansible_selinux.status == "enabled"
  tags:
    - ldap389ds_backup_selinux

- name: Set selinux policy for backup rotation
  community.general.sefcontext:
    target: '{{ item.target }}'
    setype: "{{ item.setype }}"
    reload: true
    state: "{{ item.state }}"
  register: filecontext
  with_items:
    - {target: '{{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}_backups(/.*)?', setype: 'var_log_t', state: 'present'}
  when:
    - ansible_selinux and ansible_selinux.status == "enabled"
  tags:
    - ldap389ds_backup_selinux

- name: Run restore context to reload selinux
  ansible.builtin.command: |
    restorecon -F -R -v {{ item.target }}
  with_items:
    - {index: 0, target: '{{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}_backups'}
  when:
    - filecontext.results[item.index] is changed or _backup_dir_create.changed | bool
    - ansible_selinux and ansible_selinux.status == "enabled"
  register: _result
  changed_when: _result.rc != 0
  tags:
    - ldap389ds_backup_selinux

- name: Create LDAP content
  when: ldap_initial_local_data_file | d('') is falsy
  block:

    - name: Ldap create dcObject
      community.general.ldap_entry:
        dn: "{{ ldap_base_dn }}"
        objectClass:
          - dcObject
          - organization
        attributes:
          o: "{{ ldap_organisation }}"
          dc: "{{ ldap_base_dn.split(',')[0] | regex_replace('^.{3}', '') }}"
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      tags:
        - ldap_ou

    # - name: Ldap create LDAP read only user
    #   community.general.ldap_entry:
    #     dn: "{{ 'cn=' + ldap_readonly_user_username + ',' + ldap_base_dn }}"
    #     state: absent
    #     server_uri: "{{ ldap_auth_admin.server_uri }}"
    #     bind_dn: "{{ ldap_auth_admin.bind_dn }}"
    #     bind_pw: "{{ ldap_auth_admin.bind_pw }}"
    #   tags:
    #     - ldap_ou


    - name: Ldap create domain ou ou={{ site_domain_ou }}
      community.general.ldap_entry:
        dn: ou={{ site_domain_ou }},{{ ldap_base_dn }}
        objectClass: organizationalUnit
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      tags:
        - ldap_ou

    - name: Ldap create group of unique names ou ou={{ ldap_ou_goun }}
      community.general.ldap_entry:
        dn: ou={{ ldap_ou_goun }},{{ ldap_base_dn }}
        objectClass: organizationalUnit
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      tags:
        - ldap_goun

    - name: Ldap create users und groups ou in ou={{ site_domain_ou }}
      community.general.ldap_entry:
        dn: ou={{ item }},ou={{ site_domain_ou }},{{ ldap_base_dn }}
        objectClass: organizationalUnit
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      with_items:
        - "{{ ldap_ou_users }}"
        - "{{ ldap_ou_groups }}"
      tags:
        - ldap_ou

    - name: Create groups
      community.general.ldap_entry:
        dn: cn={{ item.key }},ou={{ ldap_ou_groups }},ou={{ site_domain_ou }},{{ ldap_base_dn }}
        objectClass: posixGroup
        attributes:
          gidNumber: "{{ item.value.gid }}"
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      with_dict: "{{ site_posix_groups }}"
      tags:
        - ldap_groups

    # - name: Calculate user password hashes
    #  ansible.builtin.shell: "echo -n '{{ item.value.password }}' | openssl dgst -sha256 -binary | openssl enc -base64"
    #  register: hashes
    #  with_dict: "{{ site_posix_users }}"
    #  #when: emailusers is defined
    #  #no_log: true
    #  tags:
    #    - configuration
    #
    # - name: Create the users
    #  community.general.ldap_entry:
    #    dn: cn={{item.0.key}},ou={{ ldap_ou_users }},{{ ldap_base_dn }}
    #    objectClass:
    #      - inetOrgPerson
    #      - posixAccount
    #      - top
    #    attributes:
    #      gidNumber: "{{item.0.value.uid}}"
    #      givenName: "{{item.0.value.givenname}}"
    #      homeDirectory: "/home/{{item.0.key}}"
    #      loginShell: /bin/bash
    #      mail: "{{item.0.value.mail}}"
    #      #userPassword: "{SHA512-CRYPT}{{item.value.password}}"
    #      #userPassword: "{sha512}{{item.value.password | password_hash('sha512')}}"
    #      userPassword: "{sha512}{{ item.1.stdout }}"
    #      sn: "{sha512}{{item.0.value.password}}"
    ##      sn: "{{item.value.sn}}"
    #      uidNumber: "{{item.0.value.uid}}"
    #      uid: "{{item.0.key}}"
    #    server_uri: "{{ ldap_auth_admin.server_uri }}"
    #    bind_dn: "{{ ldap_auth_admin.bind_dn }}"
    #    bind_pw: "{{ ldap_auth_admin.bind_pw }}"
    #  with_together:
    #     - "{{ site_posix_users }}"
    #     - "{{ hashes }}"
    #  tags: skipttag

    - name: Create the users
      community.general.ldap_entry:
        dn: cn={{ item.key }},ou={{ ldap_ou_users }},ou={{ site_domain_ou }},{{ ldap_base_dn }}
        objectClass:
          - inetOrgPerson
          - posixAccount
          - top
        attributes:
          displayName: "{{ item.value.displayName }}"
          gidNumber: "{{ item.value.gid }}"
          givenName: "{{ item.value.givenname }}"
          homeDirectory: "/home/{{ item.key }}"
          loginShell: /bin/bash
          mail: "{{ item.value.mail }}"
          # userPassword: "{SHA512-CRYPT}{{item.value.password}}"
          # userPassword: "{sha512}{{item.value.password | password_hash('sha512')}}"
          # userPassword: "{sha512}{{ item.value.password }}"
          userPassword: "{{ item.value.password }}"
          sn: "{{ item.value.sn }}"
          uidNumber: "{{ item.value.uid }}"
          uid: "{{ item.key }}"
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      with_dict: "{{ site_posix_users }}"
      tags:
        - ldap_user

    - name: Update members of  posix groups
      community.general.ldap_attrs:
        dn: cn={{ item.1 }},ou={{ ldap_ou_groups }},ou={{ site_domain_ou }},{{ ldap_base_dn }}
        attributes:
          memberUid:
            - "{{ item.0.name }}"
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      with_subelements:
        - "{{ site_posix_users }}"
        - groups
      tags:
        - ldap_member

    - name: Include tasks from add_group_of_unique_names.yml
      ansible.builtin.include_tasks:
        file: add_group_of_unique_names.yml
      loop: "{{ site_gouns }}"
      loop_control:
        loop_var: _goun
      when:
        - site_gouns | length > 0

- name: Bootstrap LDAP content with slapadd
  when: ldap_initial_local_data_file | d('') is truthy
  block:
    - name: Slurp the backup file
      ansible.builtin.slurp:
        src: "{{ ldap_initial_local_data_file }}"
      register: _ldap_initial_local_data
      delegate_to: localhost

    - name: podman block
      become: "{{ podman_rootless | bool }}"
      become_user: "{{ podman_user if podman_rootless | bool else omit }}"
      block:
        - name: Prepare ldifs directory
          ansible.builtin.file:
            path: /var/tmp/ldifs
            state: directory
            mode: '0700'

        - name: Place the LDAP data file
          ansible.builtin.copy:
            dest: /var/tmp/ldifs/backup.ldif.gz
            content: "{{ _ldap_initial_local_data['content'] | b64decode }}"
            mode: '0700'

        - name: Place the initial data inside the container
          ansible.builtin.shell: |
            cd /var/tmp/ldifs
            gunzip -f /var/tmp/ldifs/backup.ldif.gz
            podman cp /var/tmp/ldifs {{ ldap389ds_container_name }}:/ldifs_manually
            # podman exec {{ ldap389ds_container_name }} ldapadd -f /ldifs_manually/backup.ldif -H 'ldapi:///' -D "cn=admin,{{
            ldap_base_dn }} " -w {{ ldap_admin_password }} -c
            podman exec {{ ldap389ds_container_name }} slapadd -c -n 2 -l /ldifs_manually/backup.ldif -F /opt/bitnami/openldap/etc/slapd.d
            rm -rf /var/tmp/ldifs
          changed_when: true
          no_log: true

    - name: debug message
      ansible.builtin.debug:
        msg: "After this slapadd restore operation it is required to run the playbook again without -e ldap_initial_local_data_file variable"
