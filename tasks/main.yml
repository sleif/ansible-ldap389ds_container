---

- name: Disable port ldap 389
  ansible.posix.firewalld:
    zone: public
    service: ldap
    permanent: true
    immediate: true
    state: disabled
  tags: firewalld

- name: Open port ldaps 636
  ansible.posix.firewalld:
    zone: public
    service: "{{ item }}"
    permanent: true
    immediate: true
    state: enabled
  loop:
    - ldaps
    # - ssh
    # - dns
  tags: firewalld

- name: Block from external network
  ansible.posix.firewalld:
    rich_rule: rule family="ipv4" source NOT address="{{
      ansible_default_ipv4.network + '/' + ansible_default_ipv4.prefix | string }}" port port="636" protocol="tcp" reject
    zone: public
    permanent: true
    immediate: true
    state: enabled

- name: Set ldap internal IP in /etc/hosts
  ansible.builtin.lineinfile:
    path: /etc/hosts
    line: "{{ ldap_host_ip_internal | d('') + ' ' + ldap_host }}"
    regexp: ".* {{ ldap_host }}"
    state: "{{ (ldap_host_ip_internal | d('') is truthy) | ternary('present', 'absent') }}"

# the next task will return:
# - _container_storage_dir_base_local
# - _container_storage_dir_base
# - _group, _owner
# - _systemd_scope
# - _systemd_service_files_dir
# - _xdg_runtime_dir
- name: Include podman_init_vars.yml from sleif.podman
  ansible.builtin.include_tasks: "{{ lookup('first_found', params) }}"
  vars:
    params:
      files: sleif.podman/tasks/includes/podman_init_vars.yml
      paths: "{{ lookup('config', 'DEFAULT_ROLES_PATH') }}"
  tags: always

- name: Certificate creation block
  tags:
    - ldap_certificate
  block:
    - name: Create certificate update script
      ansible.builtin.copy:
        dest: /usr/local/bin/ldap389ds_certificate_update.sh
        content: |
          #!/bin/bash
          podman unshare mkdir -p {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/data;
          podman unshare mkdir -p {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/ca;
          podman unshare diff -q {{ certificate_src }}/{{
          ldap_host }}/{{ ldap_host }}.crt {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/{{ ldap_host }}.crt || (
          podman unshare cp -aTLv --remove-destination {{ certificate_src }}/{{ ldap_host }} {{ _container_storage_dir_base }}/{{
          ldap389ds_container_name }}/tls;
          podman unshare csplit -z -f {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/ca/ca -b '%02d'.crt {{
          _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/{{ ldap_host }}.crt '/-----BEGIN CERTIFICATE-----/' '{*}' -q;
          podman unshare mv {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/ca/ca00.crt {{ _container_storage_dir_base }}/{{
          ldap389ds_container_name }}/tls/server.crt;
          podman unshare mv {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls/{{ ldap_host }}.key {{ _container_storage_dir_base }}/{{
          ldap389ds_container_name }}/tls/server.key;
          podman unshare chown -Rh {{ ldap389ds_container_root_uid }}:{{ ldap389ds_container_root_uid }}  {{ _container_storage_dir_base }}/{{
          ldap389ds_container_name }}/tls {{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/data
          )
        mode: '0755'

    - name: Initial fill certificate directory
      become: "{{ podman_rootless | bool }}"
      become_user: "{{ podman_user if podman_rootless | bool else omit }}"
      ansible.builtin.command: /usr/local/bin/ldap389ds_certificate_update.sh
      register: _result
      changed_when: _result.rc != 0
      until:
        - _result.rc == 0
      retries: 1
      delay: 10

    - name: Enable cronjob to provide letsencrypt certificates for ldap
      ansible.builtin.cron:
        name: "provide ldap certs"
        cron_file: ldap389ds_certificate_update
        user: "{{ podman_user }}"
        job: /usr/local/bin/ldap389ds_certificate_update.sh

    - name: Ensure cron mail go to root
      ansible.builtin.cron:
        cron_file: ldap389ds_certificate_update
        user: "{{ podman_user }}"
        env: true
        name: "MAILTO"
        job: "root"

# container initialization: /usr/libexec/dirsrv/dscontainer
- name: include_role sleif.podman podman_operation podman_create_container for ldap389ds
  # when: false
  ansible.builtin.include_role:
    name: sleif.podman
    apply:
      tags:
        - podman_container_create
  vars:
    # podman_rootless: true
    # podman_network_name: "{{ podman_networks.podman_network_rootless.podman_network_name if podman_rootless | bool else
    #   podman_networks.podman_network_root.podman_network_name }}"
    podman_operation: podman_container_create
    container_name: '{{ ldap389ds_container_name }}'
    target: "{{ pod_name if pod_name | d('') is truthy else ldap389ds_container_name }}"
    _container:
      name: '{{ container_name }}'
      image:
        name: 'quay.io/389ds/dirsrv'
        tag: '{{ ldap389ds_container_version }}'
      pod: "{{ pod_name | default('') }}"
      # network: "{{ podman_network_name if pod_name | d('') is falsy else [] }}"
      # network: "slirp4netns:port_handler=slirp4netns"
      # security_opts: label:type:docker_t
      publish: "{{ ['636:3636'] if pod_name | d('') is falsy else [] }}"
      # publish: "{{ ['3636:3636', '3389:3389'] if pod_name | d('') is falsy else [] }}"
      volumes:
        - {'host': '{{ _container_storage_dir_base_local }}/{{ ldap389ds_container_name }}/data', 'target': '/data:Z', 'mode': '0755'}
        - {'host': '{{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}/tls', 'target': '/data/tls:Z', 'mode': '0700'}
      secrets:
        - {name: 'ldap_admin_password,uid=389,gid=389,mode=0400', data: '{{ ldap_auth_admin.bind_pw }}'}
        - {name: 'ldap_config_password,uid=389,gid=389,mode=0400', data: '{{ ldap_auth_config.bind_pw }}'}
      healthcheck: 'dsctl slapd-localhost healthcheck'
      env:
        # https://www.port389.org/docs/389ds/howto/howto-deploy-389ds-on-openshift.html
        # DS_DM_PASSWORD: secretpassword
        DS_SUFFIX_NAME: "{{ ldap_base_dn }}"
        DS_DM_PASSWORD: "{{ ldap_admin_password }}"
        TZ: "Europe/Berlin"
      timezone: "Europe/Berlin"
  # no_log: true
  tags: podman_container_create

- name: Install openldap-clients
  ansible.builtin.package:
    name: openldap-clients
  tags: skipttag

- name: Add variable to ignore certificate chain
  ansible.builtin.lineinfile:
    dest: /etc/openldap/ldap.conf
    line: "TLS_REQCERT never"

- name: Install python-ldap
  ansible.builtin.package:
    name: python-ldap
  tags: skipttag

- name: Wait for healthcheck.  # noqa: no-handler
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.command: >
    podman exec {{ ldap389ds_container_name }} dsctl slapd-localhost healthcheck
  register: _healthcheck
  changed_when: false
  until:
    - _healthcheck.rc | int == 0
  retries: 30
  delay: 2
  when:
    - _podman_container_systemd_state.changed | bool

- name: Enable memberof module
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.command: >
    podman exec {{ ldap389ds_container_name }} dsconf slapd-localhost plugin memberof enable
  register: _memberoff_enable
  changed_when:
    - ("Enabled plugin" in _memberoff_enable.stdout)
  retries: 10
  delay: 5

- name: Configure memberof module  # noqa: no-handler
  community.general.ldap_attrs:
    dn: cn=MemberOf Plugin,cn=plugins,cn=config
    attributes:
      memberofgroupattr:
        - "uniqueMember"
      nsslapd-pluginEnabled:
        - "on"
    state: exact
    server_uri: "{{ ldap_auth_directory_manager.server_uri }}"
    bind_dn: "{{ ldap_auth_directory_manager.bind_dn }}"
    bind_pw: "{{ ldap_auth_directory_manager.bind_pw }}"
  register: _memberof_result
  failed_when: >
    (_memberof_result.failed | bool ) and
    ("'desc': 'Type or value exists'" not in _memberof_result.details)
  tags:
    - ldap_config_memberof
  when:
    - _memberoff_enable.changed | bool
  ignore_errors: true

- name: Restart container in case of just enabled memberof module  # noqa: no-handler
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  environment:
    XDG_RUNTIME_DIR: "{{ _xdg_runtime_dir }}"  # comes from sleif.podman
  ansible.builtin.systemd_service:
    name: "{{ ldap389ds_container_name }}"
    scope: "{{ _systemd_scope }}"  # comes from sleif.podman
    state: restarted
  when:
    - _memberoff_enable.changed | bool

- name: Wait for healthcheck after container restart  # noqa: no-handler
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.command: >
    podman exec {{ ldap389ds_container_name }} dsctl slapd-localhost healthcheck
  register: _healthcheck
  changed_when: false
  until:
    - _healthcheck.rc | int == 0
  retries: 30
  delay: 2
  when:
    - _memberoff_enable.changed | bool

- name: Check for suffix existence.
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.command: >
    podman exec {{ ldap389ds_container_name }} ldapsearch -x -H ldap://localhost:3389 -D "cn=Directory Manager" -y "/run/secrets/ldap_admin_password" -b "{{
      ldap_base_dn }}" -s base
  register: _ldapsearch_suffix
  changed_when: false
  retries: 10
  delay: 5
  failed_when:
    - _ldapsearch_suffix.rc not in [0, 32]

- name: Create the suffix
  become: "{{ podman_rootless | bool }}"
  become_user: "{{ podman_user if podman_rootless | bool else omit }}"
  ansible.builtin.command: >
    podman exec {{ ldap389ds_container_name }} dsconf -D "cn=Directory Manager" -y "/run/secrets/ldap_admin_password" ldap://localhost:3389
    backend create --suffix "{{ ldap_base_dn }}"  --be-name "userRoot" --create-suffix
  register: _create_suffix
  when:
    - _ldapsearch_suffix.rc == 32
  changed_when: true

- name: Create LDAP content - administrative users
  tags:
    - ldap_admin_users
  when: ldap_initial_local_data_file | d('') is falsy
  block:
    - name: Ldap create LDAP admin user
      community.general.ldap_entry:
        dn: "{{ ldap_auth_admin.bind_dn }}"
        objectClass:
          - simpleSecurityObject
          - organizationalRole
        attributes:
          description: "LDAP admin user"
          userPassword: "{{ ldap_auth_admin.bind_pw }}"
        server_uri: "{{ ldap_auth_directory_manager.server_uri }}"
        bind_dn: "{{ ldap_auth_directory_manager.bind_dn }}"
        bind_pw: "{{ ldap_auth_directory_manager.bind_pw }}"

    - name: Ldap create LDAP read only user
      community.general.ldap_entry:
        dn: "{{ 'cn=' + ldap_readonly_user_username + ',' + ldap_base_dn }}"
        objectClass:
          - simpleSecurityObject
          - organizationalRole
        attributes:
          description: "LDAP read only user"
          # cn: "{{ ldap_readonly_user_username }}"
          userPassword: "{{ ldap_readonly_user_password }}"
          # userPassword: "{{ '{SSHA}' + ldap_readonly_user_password }}"
        server_uri: "{{ ldap_auth_directory_manager.server_uri }}"
        bind_dn: "{{ ldap_auth_directory_manager.bind_dn }}"
        bind_pw: "{{ ldap_auth_directory_manager.bind_pw }}"

- name: setup aci for admin and ldap_readonly
  community.general.ldap_attrs:
    dn: "{{ ldap_base_dn }}"
    attributes:
      aci:
        # default domain acl
        # - (targetattr="dc || description || objectClass")(targetfilter="(objectClass=domain)")(version 3.0; acl "Enable anyone domain read";
        #   allow (read, search, compare)(userdn="ldap:///anyone");)
        - (targetattr="userPassword || shadowLastChange")(version 3.0; acl "Password policy"; allow (write) userdn="ldap:///{{
          ldap_auth_admin.bind_dn }}"; allow (write) userdn="ldap:///self"; allow (compare,search,read) userdn="ldap:///anyone";)
        - (targetattr="*")(version 3.0; acl "General access"; allow (read,search,compare) userdn="ldap:///self"; allow (all) userdn="ldap:///{{
          ldap_auth_admin.bind_dn }}"; allow (read,search,compare) userdn="ldap:///{{ 'cn=' + ldap_readonly_user_username + ',' + ldap_base_dn }}";)
    # state: exact
    server_uri: "{{ ldap_auth_directory_manager.server_uri }}"
    bind_dn: "{{ ldap_auth_directory_manager.bind_dn }}"
    bind_pw: "{{ ldap_auth_directory_manager.bind_pw }}"
  register: _aci_result
  failed_when: >
    (_aci_result.failed | bool ) and
    ("'desc': 'Type or value exists'" not in _aci_result.details)
  tags:
    - ldap_admin_users
  ignore_errors: true

- name: Backup configuration block
  tags:
    - ldap389ds_backup
  block:
    - name: Create backup directory for {{ ldap389ds_container_name }}
      ansible.builtin.file:
        path: "{{ _container_storage_dir_base }}/{{ ldap389ds_container_name }}_backups"
        state: directory
        owner: "{{ _owner }}"
        group: "{{ _group }}"
        mode: '0700'
      register: _backup_dir_create

    - name: Ensure gzip is installed
      ansible.builtin.package:
        name: gzip
        state: present

    - name: Find old backups
      ansible.builtin.find:
        paths: "{{ _container_storage_dir_base_local }}/{{ ldap389ds_container_name }}/data/bak"
        age: "14d"
        recurse: true
        file_type: directory
      register: _old_backups

    - name: Delete old backups
      ansible.builtin.file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ _old_backups.files }}"
      when: _old_backups.matched > 0

    - name: Add cronjob for daily ldap389ds data backup
      become: "{{ podman_rootless | bool }}"
      become_user: "{{ podman_user if podman_rootless | bool else omit }}"
      ansible.builtin.cron:
        name: "Daily ldap389ds backup"
        minute: "24"
        hour: "*/8"
        job: >
          podman exec "{{ ldap389ds_container_name }}" sh -c 'ldapsearch -x -D "cn=Directory Manager" -y  "/run/secrets/ldap_admin_password"
          -H ldap://localhost:3389 -b "{{ ldap_base_dn }}"
          "(objectClass=*)" > "/data/bak/{{
          ldap_base_dn | replace('=', '_') | replace(',', '_') }}_$(date +\%Y\%m\%d).ldif";
          dsconf slapd-localhost backup create | grep -v "The backup create task has finished successfully";
          for day in $(ls -1d /data/bak/localhost* | cut -dT -f1 | sort -ru | tail -n +31); do rm -rf ${day}T*; done;
          for day in $(ls -1d /data/bak/{{ ldap_base_dn | replace('=', '_') | replace(',', '_') }}_* | sort -ru | tail -n +31); do rm -rf ${day}*; done'

- name: Create LDAP content
  when: ldap_initial_local_data_file | d('') is falsy
  block:
    - name: Ldap create dcObject
      community.general.ldap_entry:
        dn: "{{ ldap_base_dn }}"
        objectClass:
          - dcObject
          - organization
        attributes:
          o: "{{ ldap_organisation }}"
          dc: "{{ ldap_base_dn.split(',')[0] | regex_replace('^.{3}', '') }}"
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      tags:
        - ldap_ou

    - name: Ldap create domain ou ou={{ site_domain_ou }}
      community.general.ldap_entry:
        dn: ou={{ site_domain_ou }},{{ ldap_base_dn }}
        objectClass: organizationalUnit
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      tags:
        - ldap_ou

    - name: Ldap create group of unique names ou ou={{ ldap_ou_goun }}
      community.general.ldap_entry:
        dn: ou={{ ldap_ou_goun }},{{ ldap_base_dn }}
        objectClass: organizationalUnit
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      tags:
        - ldap_goun

    - name: Ldap create users und groups ou in ou={{ site_domain_ou }}
      community.general.ldap_entry:
        dn: ou={{ item }},ou={{ site_domain_ou }},{{ ldap_base_dn }}
        objectClass: organizationalUnit
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      with_items:
        - "{{ ldap_ou_users }}"
        - "{{ ldap_ou_groups }}"
      tags:
        - ldap_ou

    - name: Create groups
      community.general.ldap_entry:
        dn: cn={{ item.key }},ou={{ ldap_ou_groups }},ou={{ site_domain_ou }},{{ ldap_base_dn }}
        objectClass: posixGroup
        attributes:
          gidNumber: "{{ item.value.gid }}"
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      with_dict: "{{ site_posix_groups }}"
      tags:
        - ldap_groups

    # - name: Calculate user password hashes
    #  ansible.builtin.shell: "echo -n '{{ item.value.password }}' | openssl dgst -sha256 -binary | openssl enc -base64"
    #  register: hashes
    #  with_dict: "{{ site_posix_users }}"
    #  #when: emailusers is defined
    #  #no_log: true
    #  tags:
    #    - configuration
    #
    # - name: Create the users
    #  community.general.ldap_entry:
    #    dn: cn={{item.0.key}},ou={{ ldap_ou_users }},{{ ldap_base_dn }}
    #    objectClass:
    #      - inetOrgPerson
    #      - posixAccount
    #      - top
    #    attributes:
    #      gidNumber: "{{item.0.value.uid}}"
    #      givenName: "{{item.0.value.givenname}}"
    #      homeDirectory: "/home/{{item.0.key}}"
    #      loginShell: /bin/bash
    #      mail: "{{item.0.value.mail}}"
    #      #userPassword: "{SHA512-CRYPT}{{item.value.password}}"
    #      #userPassword: "{sha512}{{item.value.password | password_hash('sha512')}}"
    #      userPassword: "{sha512}{{ item.1.stdout }}"
    #      sn: "{sha512}{{item.0.value.password}}"
    ##      sn: "{{item.value.sn}}"
    #      uidNumber: "{{item.0.value.uid}}"
    #      uid: "{{item.0.key}}"
    #    server_uri: "{{ ldap_auth_admin.server_uri }}"
    #    bind_dn: "{{ ldap_auth_admin.bind_dn }}"
    #    bind_pw: "{{ ldap_auth_admin.bind_pw }}"
    #  with_together:
    #     - "{{ site_posix_users }}"
    #     - "{{ hashes }}"
    #  tags: skipttag

    - name: Turn on nsslapd-allow-hashed-passwords
      become: "{{ podman_rootless | bool }}"
      become_user: "{{ podman_user if podman_rootless | bool else omit }}"
      ansible.builtin.command: |
        podman exec {{ ldap389ds_container_name }} dsconf slapd-localhost config replace nsslapd-allow-hashed-passwords=on
      register: _allow_hashed_passwords
      changed_when: false

    - name: Create the users
      community.general.ldap_entry:
        dn: cn={{ item.key }},ou={{ ldap_ou_users }},ou={{ site_domain_ou }},{{ ldap_base_dn }}
        objectClass:
          - inetOrgPerson
          - inetuser
          - posixAccount
          - top
        attributes:
          displayName: "{{ item.value.displayName }}"
          gidNumber: "{{ item.value.gid }}"
          givenName: "{{ item.value.givenname }}"
          homeDirectory: "/home/{{ item.key }}"
          loginShell: /bin/bash
          mail: "{{ item.value.mail }}"
          userPassword: "{{ item.value.password }}"
          sn: "{{ item.value.sn }}"
          uidNumber: "{{ item.value.uid }}"
          uid: "{{ item.key }}"
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      with_dict: "{{ site_posix_users }}"
      tags:
        - ldap_user

    - name: Turn off nsslapd-allow-hashed-passwords
      become: "{{ podman_rootless | bool }}"
      become_user: "{{ podman_user if podman_rootless | bool else omit }}"
      ansible.builtin.command: |
        podman exec {{ ldap389ds_container_name }} dsconf slapd-localhost config replace nsslapd-allow-hashed-passwords=off
      register: _allow_hashed_passwords
      changed_when: false

    - name: Update members of  posix groups
      community.general.ldap_attrs:
        dn: cn={{ item.1 }},ou={{ ldap_ou_groups }},ou={{ site_domain_ou }},{{ ldap_base_dn }}
        attributes:
          memberUid:
            - "{{ item.0.name }}"
        server_uri: "{{ ldap_auth_admin.server_uri }}"
        bind_dn: "{{ ldap_auth_admin.bind_dn }}"
        bind_pw: "{{ ldap_auth_admin.bind_pw }}"
      with_subelements:
        - "{{ site_posix_users }}"
        - groups
      tags:
        - ldap_member

    - name: Include tasks from add_group_of_unique_names.yml
      ansible.builtin.include_tasks:
        file: add_group_of_unique_names.yml
      loop: "{{ site_gouns }}"
      loop_control:
        loop_var: _goun
      when:
        - site_gouns | length > 0

- name: Bootstrap LDAP content with slapadd
  when: ldap_initial_local_data_file | d('') is truthy
  block:
    - name: Slurp the backup file
      ansible.builtin.slurp:
        src: "{{ ldap_initial_local_data_file }}"
      register: _ldap_initial_local_data
      delegate_to: localhost

    - name: podman block
      become: "{{ podman_rootless | bool }}"
      become_user: "{{ podman_user if podman_rootless | bool else omit }}"
      block:
        - name: Prepare ldifs directory
          ansible.builtin.file:
            path: /var/tmp/ldifs
            state: directory
            mode: '0700'

        - name: Place the LDAP data file
          ansible.builtin.copy:
            dest: /var/tmp/ldifs/backup.ldif
            content: "{{ _ldap_initial_local_data['content'] | b64decode }}"
            mode: '0700'

        - name: Place the initial data inside the container
          ansible.builtin.shell: |
            cd /var/tmp/ldifs
            podman cp /var/tmp/ldifs/backup.ldif {{ ldap389ds_container_name }}:/data/bak/backup.ldif
            podman exec {{ ldap389ds_container_name }} sh -c 'ldapadd -c  -f /data/bak/backup.ldif -x -D "cn=Directory Manager" \
            -y  "/run/secrets/ldap_admin_password" -H ldap://localhost:3389'
            rm -rf /var/tmp/ldifs
          changed_when: true
          register: _ldap_restore
          # no_log: true

        - name: debug message
          ansible.builtin.debug:
            var: _ldap_restore.stderr_lines
        - name: debug message
          ansible.builtin.debug:
            var: _ldap_restore.stdout_lines

    - name: debug message
      ansible.builtin.debug:
        msg: "After this slapadd restore operation it is required to run the playbook again without -e ldap_initial_local_data_file variable"
